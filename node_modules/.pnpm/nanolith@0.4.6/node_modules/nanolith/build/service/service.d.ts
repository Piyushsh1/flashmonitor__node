/// <reference types="node" resolution-mode="require"/>
import { TypedEmitter } from 'tiny-typed-emitter';
import type { Worker, TransferListItem } from 'worker_threads';
import type { TaskDefinitions, Tasks } from '../types/definitions.js';
import type { RemoveListenerFunction } from '../types/messages.js';
import type { Awaitable, CleanKeyOf } from '../types/utilities.js';
import type { ServiceCallOptions, ExitCode } from '../types/workers.js';
import type { Messenger } from '../messenger/index.js';
import type { OnStreamCallback } from '../types/streams.js';
type ServiceEvents = {
    /**
     * An event that is emitted when the service has exited its process.
     */
    terminated: (code: ExitCode) => void;
};
/**
 * Allows for the interaction between the main thread and long-running services üèÉ
 */
export declare class Service<Definitions extends TaskDefinitions> extends TypedEmitter<ServiceEvents> {
    #private;
    constructor(worker: Worker);
    /**
     * Get the current number of active calls running on the `Service` instance.
     */
    get activeCalls(): number;
    /**
     * Whether or not the underlying {@link Worker} has exited its process.
     * This will be `true` after calling `await service.close()`.
     */
    get closed(): boolean;
    /**
     * Returns the raw underlying {@link Worker} instance being used by the service.
     */
    get worker(): Worker;
    /**
     * Call a task to be run within the service.
     *
     * @param options A {@link ServiceCallOptions} object
     * @returns A promise of the task function's return value
     *
     * @example
     * const service = await api.launchService({
     *     exceptionHandler: ({ error }) => {
     *         console.log(error.message);
     *     },
     * });
     *
     * const data = await service.call({
     *     name: 'myTaskFunction',
     *     params: ['foo', 'bar', 123],
     * });
     *
     * console.log(data);
     */
    call<Name extends CleanKeyOf<Tasks<Definitions>>>({ name, params, transferList, }: ServiceCallOptions<Name, Parameters<Definitions[Name]>>): Promise<import("../types/utilities.js").UnPromisify<ReturnType<Definitions[Name]>>>;
    /**
     * By default, the service's underlying {@link Worker} is unreffed. Use this method to change that.
     */
    setRef(option: boolean): void;
    /**
     * Terminates the worker, ending its process and marking the {@link Service} instance as `closed`.
     */
    close(code?: ExitCode): Promise<undefined>;
    /**
     * @param data The data to send to the service.
     * @param transferList An optional array of {@link TransferListItem}s. See the
     * [Node.js documentation](https://nodejs.org/api/worker_threads.html#workerpostmessagevalue-transferlist) for more information.
     *
     * @example
     * service.sendMessage('foo');
     * service.sendMessage({ hello: 'world' });
     */
    sendMessage<Data = any>(data: Data, transferList?: readonly TransferListItem[]): void;
    /**
     * Create a `Writable` instance that can be piped into in order to stream data to
     * the service. The service can listen for incoming streams with the
     * `parent.onStream()` listener.
     *
     * @param metaData Any specific data about the stream that should be accessible when
     * using it.
     */
    createStream(metaData?: Record<string | number, any>): Promise<import("../streams/index.js").WritableToPort<Worker>>;
    /**
     * Receive data streams from the service.
     *
     * @param callback The callback to run once the stream has been initialized and is ready to consume.
     */
    onStream(callback: OnStreamCallback<(typeof this)['worker']>): RemoveListenerFunction;
    /**
     * Listen for messages coming from the service.
     *
     * @param callback A function to run each time a message is received from the service.
     *
     * @returns A function that will remove the listener when called.
     *
     * @example
     * service.onMessage<string>((data) => console.log(data, 'received!'));
     */
    onMessage<Data = any>(callback: (body: Data) => Awaitable<any>): RemoveListenerFunction;
    /**
     * Wait for a specific message coming from the service.
     *
     * @param callback A function returning a boolean that will be run each time a message is received from the service.
     * Once the condition is met and the function returns `true`, the promise will resolve with the data received.
     *
     * @returns A promise of the received data.
     *
     * @example
     * const data = await service.waitForMessage<{ foo: string }>(({ foo }) => foo === 'bar');
     *
     * console.log(data);
     */
    waitForMessage<Data = any>(callback: (body: Data) => Awaitable<boolean>): Promise<Data>;
    /**
     * Dynamically send a {@link Messenger} to a service.
     * Allows for the usage of `Messenger`s created after a service is launched.
     *
     * @param messenger A {@link Messenger} objectd
     * @returns A promise which resolves after the worker automatically notifies
     * the main thread that the object was received and processed.
     *
     * @example
     * const messenger = new Messenger('my-messenger');
     *
     * await service.sendMessenger(messenger);
     */
    sendMessenger(messenger: Messenger): Promise<void>;
}
export {};
