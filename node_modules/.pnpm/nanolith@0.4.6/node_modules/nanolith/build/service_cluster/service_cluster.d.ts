/// <reference types="node" resolution-mode="require"/>
import { Service } from '../service/index.js';
import type { TransferListItem } from 'worker_threads';
import type { Nanolith } from '../types/nanolith.js';
import type { ServiceWorkerOptions } from '../types/workers.js';
import type { TaskDefinitions } from '../types/definitions.js';
import type { PositiveWholeNumber } from '../types/utilities.js';
import type { ServiceClusterMapEntry, ServiceClusterOptions } from '../types/service_cluster.js';
/**
 * A lightweight API for managing multiple services using the same set
 * of task definitions and the same launch options.
 */
export declare class ServiceCluster<Definitions extends TaskDefinitions> {
    #private;
    /**
     * @param nanolith An instance of {@link Nanolith} API, returned by the `define()` function.
     */
    constructor(nanolith: Nanolith<Definitions>, options?: ServiceClusterOptions);
    /**
     * The number of currently running services on the cluster.
     */
    get activeServices(): number;
    /**
     * An array of objects for each active service on the cluster. Each object contains the
     * `service` itself, and its unique `identifier` within the cluster.
     */
    get currentServices(): ServiceClusterMapEntry<Definitions>[];
    /**
     * The number of currently active task calls on all services on the cluster.
     */
    get activeServiceCalls(): number;
    /**
     * Launch a new service on the provided {@link Nanolith} API, and automatically manage it
     * with the `ServiceCluster`.
     *
     * @param count The number of services to launch on the cluster.
     * @param options A {@link ServiceWorkerOptions} object
     * @returns A promise of a {@link Service} instance. The promise resolves once the worker is online.
     *
     * **Note:** As a safety measure, if the cluster would exceed the pool's `maxConcurrency`, this
     * function will quietly return `undefined` instead of launching a service.
     *
     * @example
     * const cluster = new ServiceCluster(api);
     *
     * // Launch 2 services on the cluster
     * await cluster.launch(2, { priority: true });
     */
    launch<Options extends ServiceWorkerOptions>(count?: 1, options?: Options): Promise<[Service<Definitions> | undefined]>;
    launch<Count extends number, Options extends ServiceWorkerOptions>(count: PositiveWholeNumber<Count>, options?: Options): Promise<(Service<Definitions> | undefined)[]>;
    /**
     * Add an already running service to the cluster.
     *
     * @param service An already running {@link Service}
     *
     * @example
     * const service = await api.launchService();
     * // ... later
     * const cluster = new ServiceCluster(api);
     * cluster.addService(service);
     */
    addService(service: Service<Definitions>): void;
    /**
     * @param identifier A unique identifier for a specific service on the cluster. Retrievable via
     * `cluster.currentServices`
     *
     * @returns The {@link Service} instance on the cluster that has the specified identifier. If
     * a service with the identifier is not found, the default behavior will be used.
     */
    use(identifier: string): Service<Definitions> | undefined;
    /**
     * @returns The {@link Service} instance on the cluster that is currently the least active.
     * If no services are active, an error will be thrown.
     */
    use(): Service<Definitions>;
    /**
     * Send the same message to all services on the cluster.
     *
     * @param data The data to send to the service.
     * @param transferList An optional array of {@link TransferListItem}s. See the
     * [Node.js documentation](https://nodejs.org/api/worker_threads.html#workerpostmessagevalue-transferlist) for more information.
     *
     * @example
     * await cluster.launch(4);
     * // All four services launched will be sent the message of "foo"
     * cluster.notifyAll('foo');
     */
    notifyAll<Data = any>(data: Data, transferList?: readonly TransferListItem[]): void;
    /**
     * Close all active services on the cluster.
     */
    closeAll(): Promise<void[]>;
    /**
     * Close all service instances on the cluster that are currently doing nothing (not running any tasks).
     */
    closeAllIdle(): Promise<void[]>;
}
