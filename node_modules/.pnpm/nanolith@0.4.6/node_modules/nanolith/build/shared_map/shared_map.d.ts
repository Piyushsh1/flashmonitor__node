import { Bytes } from '../constants/shared_map.js';
import type { SharedMapRawData, SharedMapOptions, SetWithPreviousHandler } from '../types/shared_map.js';
import type { CleanKeyOf } from '../types/utilities.js';
/**
 * A highly approachable solution to sharing memory between multiple threads ðŸ’¾
 *
 * ðŸ’¥ **Note:** Does not act exactly the same way as the {@link Map} object!
 */
export declare class SharedMap<Data extends Record<string, any>> {
    #private;
    /**
     * Each {@link SharedMap} instance has a unique key that can be used
     * to identify it.
     */
    get uniqueKey(): `${string}-${string}-${string}-${string}-${string}`;
    /**
     * A single ID assigned to the entire group of SharedMap instances using the
     * shared memory buffers.
     */
    get ID(): string;
    /**
     * An enum designed to help with assigning a fixed byte size
     * for the map's values.
     */
    static readonly option: typeof Bytes;
    /**
     * An enum designed to help with assigning a fixed byte size
     * for the map's values.
     */
    readonly option: typeof Bytes;
    get raw(): SharedMapRawData<Data>;
    constructor(data: Data, options?: SharedMapOptions);
    constructor(pair: SharedMapRawData<Data>);
    /**
     * Returns an {@link AsyncGenerator} that iterates through
     * the keys and values of the map.
     *
     * @example
     * const map = new SharedMap({ a: 1, b: 2, c: 3 });
     *
     * for await (const [key, value] of map.entries()) {
     *     console.log(key, value);
     * }
     * // Output:
     * // 'a', '1'
     * // 'b', '2'
     * // 'c', '3'
     */
    entries(): AsyncGenerator<[string, string | null], void, unknown>;
    /**
     * Retrieve items on the {@link SharedMap}.
     *
     * @param name The name of the key to retrieve the corresponding value of
     * @returns A string that can be converted back into the original data type
     */
    get<KeyName extends CleanKeyOf<Data extends SharedMapRawData<infer Type> ? Type : Data>>(name: KeyName): Promise<string | null>;
    /**
     * Set new values for existing items on the {@link SharedMap}.
     *
     * @param name The name of the key to set. The key **must** already exist on the map.
     * @param value The new value for the key.
     */
    set<KeyName extends CleanKeyOf<Data extends SharedMapRawData<infer Type> ? Type : Data>>(name: KeyName, handler: SetWithPreviousHandler<Data extends SharedMapRawData<infer Type> ? (KeyName extends keyof Type ? Type[KeyName] : Data[KeyName]) : Data[KeyName]>): Promise<void>;
    set<KeyName extends CleanKeyOf<Data extends SharedMapRawData<infer Type> ? Type : Data>>(name: KeyName, value: Data extends SharedMapRawData<infer Type> ? KeyName extends keyof Type ? Type[KeyName] : Data[KeyName] : Data[KeyName] | SetWithPreviousHandler<Data extends SharedMapRawData<infer Type> ? KeyName extends keyof Type ? Type[KeyName] : Data[KeyName] : Data[KeyName]>): Promise<void>;
    /**
     * Delete a key on the {@link SharedMap} instance.
     *
     * **Note:** Does not actually delete the key. Just sets it to "null".
     *
     * @param key The name of the key to delete.
     */
    delete<KeyName extends CleanKeyOf<Data extends SharedMapRawData<infer Type> ? Type : Data>>(name: KeyName): Promise<void>;
}
