'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakePromise = exports.VALUE = exports.PENDING = exports.REJECTED = exports.REJECT = exports.RESOLVE = exports.type = undefined;
exports.tryCatch = tryCatch;

var _symbolFor = require('symbol-for');

var _symbolFor2 = _interopRequireDefault(_symbolFor);

var _gracefulInstanceof = require('graceful-instanceof');

var _gracefulInstanceof2 = _interopRequireDefault(_gracefulInstanceof);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const type = exports.type = (0, _gracefulInstanceof2.default)('promise-faker');

const RESOLVE = exports.RESOLVE = _symbolFor2.default.for('promise-faker:resolve');
const REJECT = exports.REJECT = _symbolFor2.default.for('promise-faker:reject');
const REJECTED = exports.REJECTED = _symbolFor2.default.for('promise-faker:rejected');
const PENDING = exports.PENDING = _symbolFor2.default.for('promise-faker:pending');
const VALUE = exports.VALUE = _symbolFor2.default.for('promise-faker:value');

class FakePromise {
  constructor() {
    type.attach(this);
    this._resolved = undefined;
    this._rejected = undefined;
    this[REJECTED] = false;
    this[PENDING] = true;
  }

  [RESOLVE](subject) {
    if (!this[PENDING]) {
      return;
    }

    this[PENDING] = false;
    this._resolved = subject;
  }

  [REJECT](subject) {
    if (!this[PENDING]) {
      return;
    }

    this[PENDING] = false;
    this._rejected = subject;
    this[REJECTED] = true;
  }

  [VALUE]() {
    if (!this[REJECTED]) {
      return this._resolved;
    }

    throw this._rejected;
  }

  then(onResolve, onReject) {
    if (!this[REJECTED]) {
      return tryCatch(onResolve, this._resolved);
    }

    if (!onReject) {
      // Just skip
      return this;
    }

    return tryCatch(onReject, this._rejected);
  }

  catch(onReject) {
    if (!this[REJECTED]) {
      return this;
    }

    return tryCatch(onReject, this._rejected);
  }

  static resolve(subject, end) {
    const is = type.is(subject);

    if (!end) {
      return is ? subject : resolve(subject);
    }

    if (!is) {
      return subject;
    }

    if (subject[PENDING]) {
      throw new Error('pending unexpectedly');
    }

    return subject[VALUE]();
  }

  static reject(error) {
    const p = new FakePromise();
    p[REJECT](error);
    return p;
  }
}

exports.FakePromise = FakePromise;
function resolve(subject) {
  const p = new FakePromise();
  p[RESOLVE](subject);
  return p;
}

function tryCatch(func, ...args) {
  try {
    return FakePromise.resolve(func(...args));
  } catch (error) {
    return FakePromise.reject(error);
  }
}