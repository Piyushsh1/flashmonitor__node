'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.dfsPreOrder = dfsPreOrder;
exports.dfsPostOrder = dfsPostOrder;
exports.bfs = bfs;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [dfsPreOrder, dfsPostOrder, bfs].map(_regenerator2.default.mark);

function dfsPreOrder(node, onlyLeaves, parentSeen) {
  var seen, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, key, value;

  return _regenerator2.default.wrap(function dfsPreOrder$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!node.isLeaf()) {
            _context.next = 4;
            break;
          }

          _context.next = 3;
          return node;

        case 3:
          return _context.abrupt('return');

        case 4:
          if (onlyLeaves) {
            _context.next = 7;
            break;
          }

          _context.next = 7;
          return node;

        case 7:
          seen = parentSeen.add(node.value);
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 11;
          _iterator = (0, _getIterator3.default)(node.createIterator());

        case 13:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 19;
            break;
          }

          _step$value = (0, _slicedToArray3.default)(_step.value, 2), key = _step$value[0], value = _step$value[1];
          return _context.delegateYield(dfsPreOrder(new _node2.default(key, value, node, seen.has(value)), onlyLeaves, seen), 't0', 16);

        case 16:
          _iteratorNormalCompletion = true;
          _context.next = 13;
          break;

        case 19:
          _context.next = 25;
          break;

        case 21:
          _context.prev = 21;
          _context.t1 = _context['catch'](11);
          _didIteratorError = true;
          _iteratorError = _context.t1;

        case 25:
          _context.prev = 25;
          _context.prev = 26;

          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }

        case 28:
          _context.prev = 28;

          if (!_didIteratorError) {
            _context.next = 31;
            break;
          }

          throw _iteratorError;

        case 31:
          return _context.finish(28);

        case 32:
          return _context.finish(25);

        case 33:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked[0], this, [[11, 21, 25, 33], [26,, 28, 32]]);
}

function dfsPostOrder(node, onlyLeaves, parentSeen) {
  var seen, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, _key, _value;

  return _regenerator2.default.wrap(function dfsPostOrder$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!node.isLeaf()) {
            _context2.next = 4;
            break;
          }

          _context2.next = 3;
          return node;

        case 3:
          return _context2.abrupt('return');

        case 4:
          seen = parentSeen.add(node.value);
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context2.prev = 8;
          _iterator2 = (0, _getIterator3.default)(node.createIterator());

        case 10:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context2.next = 16;
            break;
          }

          _step2$value = (0, _slicedToArray3.default)(_step2.value, 2), _key = _step2$value[0], _value = _step2$value[1];
          return _context2.delegateYield(dfsPostOrder(new _node2.default(_key, _value, node, seen.has(_value)), onlyLeaves, seen), 't0', 13);

        case 13:
          _iteratorNormalCompletion2 = true;
          _context2.next = 10;
          break;

        case 16:
          _context2.next = 22;
          break;

        case 18:
          _context2.prev = 18;
          _context2.t1 = _context2['catch'](8);
          _didIteratorError2 = true;
          _iteratorError2 = _context2.t1;

        case 22:
          _context2.prev = 22;
          _context2.prev = 23;

          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }

        case 25:
          _context2.prev = 25;

          if (!_didIteratorError2) {
            _context2.next = 28;
            break;
          }

          throw _iteratorError2;

        case 28:
          return _context2.finish(25);

        case 29:
          return _context2.finish(22);

        case 30:
          if (onlyLeaves) {
            _context2.next = 33;
            break;
          }

          _context2.next = 33;
          return node;

        case 33:
        case 'end':
          return _context2.stop();
      }
    }
  }, _marked[1], this, [[8, 18, 22, 30], [23,, 25, 29]]);
}

// transpiled generator has uncovered branches
// istanbul issue #645
/* istanbul ignore next */
function bfs(rootNode, onlyLeaves, parentSeen) {
  var queue, i, node, seen, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _step3$value, _key2, _value2;

  return _regenerator2.default.wrap(function bfs$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          queue = [{ node: rootNode, seen: parentSeen }];
          i = 0;

        case 2:
          if (!(i < queue.length)) {
            _context3.next = 35;
            break;
          }

          node = queue[i].node;

          if (!node.isLeaf()) {
            _context3.next = 9;
            break;
          }

          _context3.next = 7;
          return node;

        case 7:
          _context3.next = 32;
          break;

        case 9:
          if (onlyLeaves) {
            _context3.next = 12;
            break;
          }

          _context3.next = 12;
          return node;

        case 12:
          seen = queue[i].seen.add(node.value);
          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context3.prev = 16;

          for (_iterator3 = (0, _getIterator3.default)(node.createIterator()); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            _step3$value = (0, _slicedToArray3.default)(_step3.value, 2), _key2 = _step3$value[0], _value2 = _step3$value[1];

            queue.push({
              node: new _node2.default(_key2, _value2, node, seen.has(_value2)),
              seen: seen
            });
          }
          _context3.next = 24;
          break;

        case 20:
          _context3.prev = 20;
          _context3.t0 = _context3['catch'](16);
          _didIteratorError3 = true;
          _iteratorError3 = _context3.t0;

        case 24:
          _context3.prev = 24;
          _context3.prev = 25;

          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }

        case 27:
          _context3.prev = 27;

          if (!_didIteratorError3) {
            _context3.next = 30;
            break;
          }

          throw _iteratorError3;

        case 30:
          return _context3.finish(27);

        case 31:
          return _context3.finish(24);

        case 32:
          i++;
          _context3.next = 2;
          break;

        case 35:
        case 'end':
          return _context3.stop();
      }
    }
  }, _marked[2], this, [[16, 20, 24, 32], [25,, 27, 31]]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zZWFyY2guanMiXSwibmFtZXMiOlsiZGZzUHJlT3JkZXIiLCJkZnNQb3N0T3JkZXIiLCJiZnMiLCJub2RlIiwib25seUxlYXZlcyIsInBhcmVudFNlZW4iLCJpc0xlYWYiLCJzZWVuIiwiYWRkIiwidmFsdWUiLCJjcmVhdGVJdGVyYXRvciIsImtleSIsImhhcyIsInJvb3ROb2RlIiwicXVldWUiLCJpIiwibGVuZ3RoIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBRWlCQSxXLEdBQUFBLFc7UUFrQkFDLFksR0FBQUEsWTtRQXFCQUMsRyxHQUFBQSxHOztBQXpDakI7Ozs7OztlQUVpQkYsVyxFQWtCQUMsWSxFQXFCQUMsRzs7QUF2Q1YsU0FBVUYsV0FBVixDQUFzQkcsSUFBdEIsRUFBNEJDLFVBQTVCLEVBQXdDQyxVQUF4QztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFDREYsS0FBS0csTUFBTCxFQURDO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsaUJBRUdILElBRkg7O0FBQUE7QUFBQTs7QUFBQTtBQUFBLGNBS0FDLFVBTEE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxpQkFNR0QsSUFOSDs7QUFBQTtBQVFDSSxjQVJELEdBUVFGLFdBQVdHLEdBQVgsQ0FBZUwsS0FBS00sS0FBcEIsQ0FSUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaURBU29CTixLQUFLTyxjQUFMLEVBVHBCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsc0VBU0tDLEdBVEwsbUJBU1VGLEtBVFY7QUFBQSx3Q0FVSVQsWUFDTCxtQkFBU1csR0FBVCxFQUFjRixLQUFkLEVBQXFCTixJQUFyQixFQUEyQkksS0FBS0ssR0FBTCxDQUFTSCxLQUFULENBQTNCLENBREssRUFFTEwsVUFGSyxFQUdMRyxJQUhLLENBVko7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFB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Jy4vbm9kZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiogZGZzUHJlT3JkZXIobm9kZSwgb25seUxlYXZlcywgcGFyZW50U2Vlbikge1xuICBpZiAobm9kZS5pc0xlYWYoKSkge1xuICAgIHlpZWxkIG5vZGU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghb25seUxlYXZlcykge1xuICAgIHlpZWxkIG5vZGU7XG4gIH1cbiAgY29uc3Qgc2VlbiA9IHBhcmVudFNlZW4uYWRkKG5vZGUudmFsdWUpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygbm9kZS5jcmVhdGVJdGVyYXRvcigpKSB7XG4gICAgeWllbGQqIGRmc1ByZU9yZGVyKFxuICAgICAgbmV3IE5vZGUoa2V5LCB2YWx1ZSwgbm9kZSwgc2Vlbi5oYXModmFsdWUpKSxcbiAgICAgIG9ubHlMZWF2ZXMsXG4gICAgICBzZWVuXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIGRmc1Bvc3RPcmRlcihub2RlLCBvbmx5TGVhdmVzLCBwYXJlbnRTZWVuKSB7XG4gIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgeWllbGQgbm9kZTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2VlbiA9IHBhcmVudFNlZW4uYWRkKG5vZGUudmFsdWUpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygbm9kZS5jcmVhdGVJdGVyYXRvcigpKSB7XG4gICAgeWllbGQqIGRmc1Bvc3RPcmRlcihcbiAgICAgIG5ldyBOb2RlKGtleSwgdmFsdWUsIG5vZGUsIHNlZW4uaGFzKHZhbHVlKSksXG4gICAgICBvbmx5TGVhdmVzLFxuICAgICAgc2VlblxuICAgICk7XG4gIH1cbiAgaWYgKCFvbmx5TGVhdmVzKSB7XG4gICAgeWllbGQgbm9kZTtcbiAgfVxufVxuXG4vLyB0cmFuc3BpbGVkIGdlbmVyYXRvciBoYXMgdW5jb3ZlcmVkIGJyYW5jaGVzXG4vLyBpc3RhbmJ1bCBpc3N1ZSAjNjQ1XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBiZnMocm9vdE5vZGUsIG9ubHlMZWF2ZXMsIHBhcmVudFNlZW4pIHtcbiAgY29uc3QgcXVldWUgPSBbe25vZGU6IHJvb3ROb2RlLCBzZWVuOiBwYXJlbnRTZWVufV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gcXVldWVbaV0ubm9kZTtcbiAgICBpZiAobm9kZS5pc0xlYWYoKSkge1xuICAgICAgeWllbGQgbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFvbmx5TGVhdmVzKSB7XG4gICAgICAgIHlpZWxkIG5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWVuID0gcXVldWVbaV0uc2Vlbi5hZGQobm9kZS52YWx1ZSk7XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygbm9kZS5jcmVhdGVJdGVyYXRvcigpKSB7XG4gICAgICAgIHF1ZXVlLnB1c2goe1xuICAgICAgICAgIG5vZGU6IG5ldyBOb2RlKGtleSwgdmFsdWUsIG5vZGUsIHNlZW4uaGFzKHZhbHVlKSksXG4gICAgICAgICAgc2VlblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==